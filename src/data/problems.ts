import { Problem } from "./types";

export const problems: Problem[] = [
  // ============ EASY PROBLEMS ============
  {
    id: "two-sum",
    title: "Two Sum",
    leetcodeId: 1,
    leetcodeUrl: "https://leetcode.com/problems/two-sum/",
    difficulty: "easy",
    topics: ["arrays", "hash-table"],
    description:
      "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.",
    hints: [
      { level: 1, content: "Think about what you're looking for at each element - what value would complete the pair?" },
      { level: 2, content: "Can you use a data structure to remember what numbers you've already seen?" },
      { level: 3, content: "A HashMap can give O(1) lookup time. Store each number and its index as you iterate." },
      { level: 4, content: "For each number, check if (target - current) exists in your HashMap." },
    ],
    patterns: ["hash-map-lookup", "complement-search"],
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    companies: ["Google", "Amazon", "Facebook", "Microsoft", "Apple"],
  },
  {
    id: "valid-parentheses",
    title: "Valid Parentheses",
    leetcodeId: 20,
    leetcodeUrl: "https://leetcode.com/problems/valid-parentheses/",
    difficulty: "easy",
    topics: ["strings", "stack"],
    description:
      "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.",
    hints: [
      { level: 1, content: "What data structure follows LIFO (Last In, First Out) principle?" },
      { level: 2, content: "When you see an opening bracket, you expect a matching closing bracket later." },
      { level: 3, content: "Use a stack to keep track of opening brackets. When you see a closing bracket, check if it matches the top of the stack." },
      { level: 4, content: "Push opening brackets onto stack. For closing brackets, pop and compare. Stack should be empty at the end." },
    ],
    patterns: ["stack-matching", "bracket-validation"],
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    companies: ["Amazon", "Facebook", "Bloomberg"],
  },
  {
    id: "merge-two-sorted-lists",
    title: "Merge Two Sorted Lists",
    leetcodeId: 21,
    leetcodeUrl: "https://leetcode.com/problems/merge-two-sorted-lists/",
    difficulty: "easy",
    topics: ["linked-list", "recursion"],
    description:
      "Merge two sorted linked lists and return it as a sorted list.",
    hints: [
      { level: 1, content: "Compare the heads of both lists. Which one should come first in the merged list?" },
      { level: 2, content: "You can solve this iteratively with a dummy head node, or recursively." },
      { level: 3, content: "Create a dummy node to simplify edge cases. Use a pointer to build the result list." },
      { level: 4, content: "Compare nodes from both lists, attach the smaller one to result, and advance that list's pointer." },
    ],
    patterns: ["merge-technique", "dummy-head"],
    timeComplexity: "O(n + m)",
    spaceComplexity: "O(1) iterative, O(n + m) recursive",
    companies: ["Amazon", "Microsoft", "Apple"],
  },
  {
    id: "best-time-to-buy-sell-stock",
    title: "Best Time to Buy and Sell Stock",
    leetcodeId: 121,
    leetcodeUrl: "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
    difficulty: "easy",
    topics: ["arrays", "dynamic-programming"],
    description:
      "Find the maximum profit you can achieve from buying and selling a stock once.",
    hints: [
      { level: 1, content: "You want to buy low and sell high. What information do you need to track?" },
      { level: 2, content: "As you iterate, keep track of the minimum price seen so far." },
      { level: 3, content: "At each day, calculate potential profit if you sold today (current price - min price so far)." },
      { level: 4, content: "Track minPrice and maxProfit. Update minPrice = min(minPrice, price). Update maxProfit = max(maxProfit, price - minPrice)." },
    ],
    patterns: ["kadane-variant", "track-minimum"],
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    companies: ["Amazon", "Facebook", "Microsoft", "Goldman Sachs"],
  },
  {
    id: "valid-palindrome",
    title: "Valid Palindrome",
    leetcodeId: 125,
    leetcodeUrl: "https://leetcode.com/problems/valid-palindrome/",
    difficulty: "easy",
    topics: ["strings", "two-pointers"],
    description:
      "Determine if a string is a palindrome, considering only alphanumeric characters and ignoring cases.",
    hints: [
      { level: 1, content: "A palindrome reads the same forwards and backwards. How can you compare characters from both ends?" },
      { level: 2, content: "Use two pointers - one at the start, one at the end." },
      { level: 3, content: "Skip non-alphanumeric characters. Compare characters case-insensitively." },
      { level: 4, content: "Move left pointer right and right pointer left. If characters don't match, return false." },
    ],
    patterns: ["two-pointers", "string-cleaning"],
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    companies: ["Facebook", "Microsoft", "Apple"],
  },
  {
    id: "invert-binary-tree",
    title: "Invert Binary Tree",
    leetcodeId: 226,
    leetcodeUrl: "https://leetcode.com/problems/invert-binary-tree/",
    difficulty: "easy",
    topics: ["binary-tree", "recursion"],
    description: "Invert a binary tree (mirror it).",
    hints: [
      { level: 1, content: "What does it mean to invert a tree? Each node's left and right children are swapped." },
      { level: 2, content: "Think recursively - if you invert the subtrees, what's left to do?" },
      { level: 3, content: "Swap the left and right children of each node, then recursively invert the subtrees." },
      { level: 4, content: "Base case: null node returns null. Swap left and right, then recurse on both children." },
    ],
    patterns: ["tree-recursion", "swap"],
    timeComplexity: "O(n)",
    spaceComplexity: "O(h) where h is height",
    companies: ["Google", "Amazon"],
  },
  {
    id: "maximum-subarray",
    title: "Maximum Subarray",
    leetcodeId: 53,
    leetcodeUrl: "https://leetcode.com/problems/maximum-subarray/",
    difficulty: "medium",
    topics: ["arrays", "dynamic-programming", "divide-and-conquer"],
    description:
      "Find the contiguous subarray with the largest sum.",
    hints: [
      { level: 1, content: "At each position, you have a choice: start a new subarray or extend the current one." },
      { level: 2, content: "This is a classic application of Kadane's algorithm." },
      { level: 3, content: "Track current sum and max sum. If current sum becomes negative, reset it." },
      { level: 4, content: "currentSum = max(num, currentSum + num). maxSum = max(maxSum, currentSum)." },
    ],
    patterns: ["kadane-algorithm", "running-sum"],
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    companies: ["Amazon", "Microsoft", "Apple", "LinkedIn"],
  },

  // ============ MEDIUM PROBLEMS ============
  {
    id: "longest-substring-without-repeating",
    title: "Longest Substring Without Repeating Characters",
    leetcodeId: 3,
    leetcodeUrl: "https://leetcode.com/problems/longest-substring-without-repeating-characters/",
    difficulty: "medium",
    topics: ["strings", "sliding-window", "hash-table"],
    description:
      "Find the length of the longest substring without repeating characters.",
    hints: [
      { level: 1, content: "You need to track a window of unique characters. What happens when you find a duplicate?" },
      { level: 2, content: "Use a sliding window approach with two pointers." },
      { level: 3, content: "Use a Set or HashMap to track characters in the current window." },
      { level: 4, content: "Expand right pointer. If duplicate found, shrink from left until no duplicate. Track max length." },
    ],
    patterns: ["sliding-window", "hash-set"],
    timeComplexity: "O(n)",
    spaceComplexity: "O(min(m, n)) where m is charset size",
    companies: ["Amazon", "Facebook", "Microsoft", "Bloomberg", "Apple"],
  },
  {
    id: "container-with-most-water",
    title: "Container With Most Water",
    leetcodeId: 11,
    leetcodeUrl: "https://leetcode.com/problems/container-with-most-water/",
    difficulty: "medium",
    topics: ["arrays", "two-pointers", "greedy"],
    description:
      "Find two lines that together with the x-axis form a container that holds the most water.",
    hints: [
      { level: 1, content: "The area is determined by the shorter line and the distance between lines." },
      { level: 2, content: "Start with the widest container (first and last lines). How can you potentially find a larger area?" },
      { level: 3, content: "Use two pointers at both ends. Move the pointer pointing to the shorter line inward." },
      { level: 4, content: "Area = min(height[left], height[right]) * (right - left). Move the shorter side inward." },
    ],
    patterns: ["two-pointers", "greedy-choice"],
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    companies: ["Amazon", "Facebook", "Google", "Bloomberg"],
  },
  {
    id: "3sum",
    title: "3Sum",
    leetcodeId: 15,
    leetcodeUrl: "https://leetcode.com/problems/3sum/",
    difficulty: "medium",
    topics: ["arrays", "two-pointers", "sorting"],
    description:
      "Find all unique triplets in the array which gives the sum of zero.",
    hints: [
      { level: 1, content: "How can you reduce this to a Two Sum problem?" },
      { level: 2, content: "Sort the array first. Then for each element, find two others that sum to its negative." },
      { level: 3, content: "Use two pointers for the Two Sum part. Skip duplicates to avoid duplicate triplets." },
      { level: 4, content: "Fix one number, use two pointers on the rest. Skip duplicates at all three positions." },
    ],
    patterns: ["two-pointers", "sorting", "duplicate-handling"],
    timeComplexity: "O(n²)",
    spaceComplexity: "O(1) or O(n) for sorting",
    companies: ["Facebook", "Amazon", "Microsoft", "Apple", "Bloomberg"],
  },
  {
    id: "number-of-islands",
    title: "Number of Islands",
    leetcodeId: 200,
    leetcodeUrl: "https://leetcode.com/problems/number-of-islands/",
    difficulty: "medium",
    topics: ["graph", "binary-tree", "recursion"],
    description:
      "Count the number of islands in a 2D grid where '1' is land and '0' is water.",
    hints: [
      { level: 1, content: "An island is a group of connected '1's. How do you identify all cells belonging to one island?" },
      { level: 2, content: "When you find a '1', explore all connected '1's using DFS or BFS." },
      { level: 3, content: "Mark visited cells to avoid counting them again. You can modify the grid or use a visited set." },
      { level: 4, content: "Iterate through grid. When you find '1', increment count and use DFS/BFS to mark all connected '1's as visited." },
    ],
    patterns: ["dfs", "bfs", "flood-fill"],
    timeComplexity: "O(m × n)",
    spaceComplexity: "O(m × n) worst case for recursion stack",
    companies: ["Amazon", "Microsoft", "Facebook", "Google", "Bloomberg"],
  },
  {
    id: "coin-change",
    title: "Coin Change",
    leetcodeId: 322,
    leetcodeUrl: "https://leetcode.com/problems/coin-change/",
    difficulty: "medium",
    topics: ["dynamic-programming", "arrays"],
    description:
      "Find the fewest number of coins needed to make up a given amount.",
    hints: [
      { level: 1, content: "This is an optimization problem. What are the subproblems?" },
      { level: 2, content: "For amount X, the answer depends on answers for smaller amounts (X - coin value)." },
      { level: 3, content: "Use DP where dp[i] = minimum coins needed for amount i." },
      { level: 4, content: "dp[0] = 0. For each amount from 1 to target, try each coin: dp[i] = min(dp[i], dp[i-coin] + 1)." },
    ],
    patterns: ["bottom-up-dp", "unbounded-knapsack"],
    timeComplexity: "O(amount × coins)",
    spaceComplexity: "O(amount)",
    companies: ["Amazon", "Microsoft", "Goldman Sachs"],
  },
  {
    id: "product-of-array-except-self",
    title: "Product of Array Except Self",
    leetcodeId: 238,
    leetcodeUrl: "https://leetcode.com/problems/product-of-array-except-self/",
    difficulty: "medium",
    topics: ["arrays"],
    description:
      "Return an array where each element is the product of all other elements, without using division.",
    hints: [
      { level: 1, content: "For each position, you need the product of all elements to its left AND all elements to its right." },
      { level: 2, content: "Can you precompute prefix products and suffix products?" },
      { level: 3, content: "First pass: compute prefix products. Second pass: multiply by suffix products." },
      { level: 4, content: "Use output array for prefix products. Then iterate backwards multiplying by running suffix product." },
    ],
    patterns: ["prefix-product", "suffix-product"],
    timeComplexity: "O(n)",
    spaceComplexity: "O(1) excluding output array",
    companies: ["Amazon", "Facebook", "Apple", "Microsoft"],
  },
  {
    id: "binary-tree-level-order-traversal",
    title: "Binary Tree Level Order Traversal",
    leetcodeId: 102,
    leetcodeUrl: "https://leetcode.com/problems/binary-tree-level-order-traversal/",
    difficulty: "medium",
    topics: ["binary-tree", "queue"],
    description:
      "Return the level order traversal of a binary tree (values level by level, left to right).",
    hints: [
      { level: 1, content: "Level order traversal visits nodes level by level. What data structure processes nodes in order?" },
      { level: 2, content: "Use BFS with a queue. Process all nodes at current level before moving to next." },
      { level: 3, content: "Track the number of nodes at each level to know when a level ends." },
      { level: 4, content: "Use queue. For each level, process queue.length nodes, adding their children to queue." },
    ],
    patterns: ["bfs", "level-tracking"],
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    companies: ["Amazon", "Facebook", "Microsoft", "Bloomberg"],
  },
  {
    id: "validate-binary-search-tree",
    title: "Validate Binary Search Tree",
    leetcodeId: 98,
    leetcodeUrl: "https://leetcode.com/problems/validate-binary-search-tree/",
    difficulty: "medium",
    topics: ["binary-search-tree", "recursion"],
    description:
      "Determine if a binary tree is a valid binary search tree.",
    hints: [
      { level: 1, content: "A BST has all left descendants < node < all right descendants. Just checking immediate children isn't enough." },
      { level: 2, content: "Each node must be within a valid range. How does the range change as you go left or right?" },
      { level: 3, content: "Pass min and max bounds to each recursive call. Update bounds when going left/right." },
      { level: 4, content: "validate(node, min, max). Going left: max becomes node.val. Going right: min becomes node.val." },
    ],
    patterns: ["tree-recursion", "range-validation"],
    timeComplexity: "O(n)",
    spaceComplexity: "O(h)",
    companies: ["Amazon", "Facebook", "Microsoft"],
  },
  {
    id: "lru-cache",
    title: "LRU Cache",
    leetcodeId: 146,
    leetcodeUrl: "https://leetcode.com/problems/lru-cache/",
    difficulty: "medium",
    topics: ["hash-table", "linked-list"],
    description:
      "Design a data structure that follows the Least Recently Used (LRU) cache eviction policy.",
    hints: [
      { level: 1, content: "You need O(1) access AND O(1) update of recency. What combination of data structures achieves this?" },
      { level: 2, content: "HashMap gives O(1) lookup. Doubly linked list gives O(1) removal and insertion at ends." },
      { level: 3, content: "HashMap maps key to node in doubly linked list. Most recent at head, least recent at tail." },
      { level: 4, content: "On get/put: move node to head. On put when full: remove tail node and its HashMap entry." },
    ],
    patterns: ["hash-map", "doubly-linked-list"],
    timeComplexity: "O(1) for both operations",
    spaceComplexity: "O(capacity)",
    companies: ["Amazon", "Facebook", "Microsoft", "Google", "Apple"],
  },

  // ============ HARD PROBLEMS ============
  {
    id: "median-of-two-sorted-arrays",
    title: "Median of Two Sorted Arrays",
    leetcodeId: 4,
    leetcodeUrl: "https://leetcode.com/problems/median-of-two-sorted-arrays/",
    difficulty: "hard",
    topics: ["arrays", "binary-search", "divide-and-conquer"],
    description:
      "Find the median of two sorted arrays in O(log(m+n)) time.",
    hints: [
      { level: 1, content: "The median divides the combined array into two equal halves. Can you find the partition point?" },
      { level: 2, content: "Binary search on the smaller array to find the correct partition." },
      { level: 3, content: "If you partition array1 at i, you must partition array2 at (m+n+1)/2 - i." },
      { level: 4, content: "Valid partition: max(left1, left2) <= min(right1, right2). Adjust binary search based on this." },
    ],
    patterns: ["binary-search", "partition"],
    timeComplexity: "O(log(min(m, n)))",
    spaceComplexity: "O(1)",
    companies: ["Amazon", "Google", "Microsoft", "Apple"],
  },
  {
    id: "merge-k-sorted-lists",
    title: "Merge k Sorted Lists",
    leetcodeId: 23,
    leetcodeUrl: "https://leetcode.com/problems/merge-k-sorted-lists/",
    difficulty: "hard",
    topics: ["linked-list", "heap", "divide-and-conquer"],
    description:
      "Merge k sorted linked lists into one sorted linked list.",
    hints: [
      { level: 1, content: "You need to efficiently find the minimum among k list heads at each step." },
      { level: 2, content: "A min-heap can give you the minimum in O(log k) time." },
      { level: 3, content: "Add all list heads to a min-heap. Pop minimum, add to result, push its next node." },
      { level: 4, content: "Alternative: Divide and conquer - merge pairs of lists, reducing k by half each round." },
    ],
    patterns: ["min-heap", "divide-and-conquer"],
    timeComplexity: "O(n log k) where n is total nodes",
    spaceComplexity: "O(k) for heap",
    companies: ["Amazon", "Facebook", "Microsoft", "Google"],
  },
  {
    id: "trapping-rain-water",
    title: "Trapping Rain Water",
    leetcodeId: 42,
    leetcodeUrl: "https://leetcode.com/problems/trapping-rain-water/",
    difficulty: "hard",
    topics: ["arrays", "two-pointers", "dynamic-programming", "stack"],
    description:
      "Calculate how much water can be trapped after raining given elevation map.",
    hints: [
      { level: 1, content: "Water at each position depends on the minimum of max heights on left and right." },
      { level: 2, content: "Water[i] = min(maxLeft[i], maxRight[i]) - height[i]" },
      { level: 3, content: "You can precompute maxLeft and maxRight arrays, or use two pointers." },
      { level: 4, content: "Two pointers: move the pointer with smaller max. Water is determined by the smaller side." },
    ],
    patterns: ["two-pointers", "prefix-max", "suffix-max"],
    timeComplexity: "O(n)",
    spaceComplexity: "O(1) with two pointers",
    companies: ["Amazon", "Facebook", "Google", "Microsoft", "Goldman Sachs"],
  },
  {
    id: "word-ladder",
    title: "Word Ladder",
    leetcodeId: 127,
    leetcodeUrl: "https://leetcode.com/problems/word-ladder/",
    difficulty: "hard",
    topics: ["graph", "strings", "hash-table"],
    description:
      "Find the shortest transformation sequence from beginWord to endWord, changing one letter at a time.",
    hints: [
      { level: 1, content: "This is a shortest path problem. What algorithm finds shortest paths in unweighted graphs?" },
      { level: 2, content: "Use BFS where each word is a node, and edges connect words differing by one letter." },
      { level: 3, content: "For each word, try changing each character to a-z and check if it's in the word list." },
      { level: 4, content: "Use a Set for O(1) lookup. BFS level by level, tracking visited words to avoid cycles." },
    ],
    patterns: ["bfs", "graph-traversal"],
    timeComplexity: "O(M² × N) where M is word length, N is word list size",
    spaceComplexity: "O(M × N)",
    companies: ["Amazon", "Facebook", "Microsoft", "Google"],
  },
  {
    id: "longest-increasing-path-in-matrix",
    title: "Longest Increasing Path in a Matrix",
    leetcodeId: 329,
    leetcodeUrl: "https://leetcode.com/problems/longest-increasing-path-in-a-matrix/",
    difficulty: "hard",
    topics: ["dynamic-programming", "graph", "recursion"],
    description:
      "Find the length of the longest increasing path in a matrix.",
    hints: [
      { level: 1, content: "From each cell, you can move to adjacent cells with larger values. This forms a DAG." },
      { level: 2, content: "Use DFS with memoization. The longest path from a cell doesn't change." },
      { level: 3, content: "memo[i][j] = 1 + max(DFS of valid neighbors). Valid = neighbor value > current value." },
      { level: 4, content: "No need for visited array since we only move to larger values (no cycles possible)." },
    ],
    patterns: ["dfs", "memoization", "dag"],
    timeComplexity: "O(m × n)",
    spaceComplexity: "O(m × n)",
    companies: ["Google", "Amazon", "Facebook"],
  },
  {
    id: "serialize-deserialize-binary-tree",
    title: "Serialize and Deserialize Binary Tree",
    leetcodeId: 297,
    leetcodeUrl: "https://leetcode.com/problems/serialize-and-deserialize-binary-tree/",
    difficulty: "hard",
    topics: ["binary-tree", "strings", "recursion"],
    description:
      "Design an algorithm to serialize and deserialize a binary tree.",
    hints: [
      { level: 1, content: "You need to capture the structure of the tree, including null nodes." },
      { level: 2, content: "Preorder traversal with null markers can uniquely represent a tree." },
      { level: 3, content: "Serialize: preorder traversal, use a marker (like 'null') for null nodes." },
      { level: 4, content: "Deserialize: use a queue/iterator of values. Recursively build left then right subtree." },
    ],
    patterns: ["preorder-traversal", "tree-serialization"],
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    companies: ["Amazon", "Facebook", "Microsoft", "Google", "LinkedIn"],
  },
];

export const getProblemById = (id: string): Problem | undefined => {
  return problems.find((p) => p.id === id);
};

export const getProblemsByDifficulty = (difficulty: Problem["difficulty"]): Problem[] => {
  return problems.filter((p) => p.difficulty === difficulty);
};

export const getProblemsByTopic = (topic: string): Problem[] => {
  return problems.filter((p) => p.topics.includes(topic as Problem["topics"][number]));
};

export const getProblemCount = () => ({
  total: problems.length,
  easy: problems.filter((p) => p.difficulty === "easy").length,
  medium: problems.filter((p) => p.difficulty === "medium").length,
  hard: problems.filter((p) => p.difficulty === "hard").length,
});
